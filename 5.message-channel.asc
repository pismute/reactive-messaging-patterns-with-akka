== ch5. Messaging channels

이번 장에 대한 소개

* Point to Point channel
* publish subscribe channel
* Datatype channel
* Invalid Message channel
* Dead letter channel
* Guaranteed Delivery
* Channel Adapter
* Message Bridge
* Message Bus

.EIP 패턴과 연결하면
[cols="^1,^2",frame="topbot",options="header,footer"]
|======================
| EIP | 책
|One to One |Point to Point Channel
|One to Many |Publish Subscribe Channel
|What type of data |Datatype Channel
|Invalid and dead message |Invalid Message Channel, Dead letter channel
|Crash Proof |Guaranteed Delivery
|non messaging clients, adaptive messaging channels |channel adapter, message bridge
|communications backbone |message bus
|======================

=== Point to Point Channel

image::img/5-1.png[]

* 모든 메시지 채널(메세지 생산자와 소비자가 통신하는 것, 모두 decouple
        되어있어야함)은 Point to Point Channel

image::img/5-2.png[]

* Event driven counsumer
* Sequential message delivery, 기본적으로 mailbox는 FIFO

=== Publish Subscribe Channel

image::img/5-3.png[]

* Publish Subscribe pattern (POSA1), Observer Pattern (GoF)

image::img/5-4.png[]

==== Local Event Stream

* 내장 pub-sub 채널은 Event Bus trait을 사용
* Event Bus의 표준 인스턴스는 Event Stream
* LookupClassification : event type을 활용
* SubchannelClassification : event type, subtype을 활용
* ScanningClassification :

image::img/5-5.png[]

==== Distributed Publish-Subscribe

* 내장 Akka cluster에서 사용가능한 내장 pub-sub 채널
* Cluster 내에 있는 어딘가의 하나의 actor 혹은 여러 actor에 메시지를 전달
* DistributedPubSubMediator를 사용해서 처리
* Mediator는 모든 node에서 동작해야 하며, 모든 pub-sub 토픽에 참여 하거나 sender-receiver 공동 작업이 가능해야함

image::img/5-6.png[]

* role - role 이름이 주어지면 cluster nodes에서 시작이 가능하며, “”으로 시작하면 모든 클러스터 노드에서 시작한다.
* routing-logic 하나의 클러스터가 multiple actor에 send하는 경우 (publish 말고) - random, RR, braodcast
* gossip-interval mediator끼리 통신하는 시간 (각자의 가입자들을 공유 함)
* removed-time-to-live mediator에서 삭제된 node들 정보 공유

image::img/5-7.png[]

actor가 종료 되면, 로컬 mediator에서 자동으로 unregister, unsubscribe된다.

==== Datatype Channel

image::img/5-8.png[]

* 들어오는 메시지의 data type을 알아야한다.

image::img/5-9.png[]

Actor model을 사용한다면 일반적으로 type safe message를 사용하기 때문에 수월함

가끔 이 기종 연결에서 문제가 있음 예를 들어 RabbitMQ or JMS라고 할때 모든 메세지가 binary byte array로 들어온다. Message Translator를 사용해서 해당 메시지를 convert해서 사용해야한다.

=== Invalid Message Channel

image::img/5-10.png[]

메세지 채널에서 메세지를 보낸다는 것은 메세지의 타입이 리시버에 의해 받아졌다는 것을 의미한다. 받은 메시지가 해석이 안되는 경우 Invalid message로 처리

image::img/5-11.png[]

Authenticator같은 경우에 사용 가능. Pipes and Filters를 사용 해서 메시지를 처리하고 invalid 경우 로깅, noti등 처리 한다.

=== Dead Letter Channel

image::img/5-12.png[]

메시지가 전송되지 못하는 경우

image::img/5-13.png[]

* dead letter가 생기는 이유
** local actor 에서 다른 local actor로 메시지를 보내는데 actor가 죽어있는 경우
** 다른 node의 actor로 메시지를 보내는데 네트워크 연결이 끊어진 경우
** 네트워크가 연결잘되어있는 다른 node의 actor로 메시지 보내지만 actor가 죽어있는 경우

guranteed delivery를 위해서 필요한 것이 DeadLetter 시스템임
